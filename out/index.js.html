<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

/**
 * Given a Poisson process, the probability of obtaining exactly n successes in N trials is given by the limit of a binomial distribution
 * http://en.wikipedia.org/wiki/Poisson_process
 * @return {Array&lt;nuber:positive>} An array with the times of each arrival in a Poisson Process
 * @param {number:positive} lambda (rate)
 * @param {number:positive} T (time)
 * @param {boolean} path
 */
var poissP = module.exports.poissP = function(lambda, T, path) {
  var U, exp, N_t, t, n;
  N_t = [0];
  t = 0;
  n = 0;

  if (T &lt;= 0 || lambda &lt;= 0) {
    return N_t;
  }

  while (t &lt; T) {
    U = Math.random();
    exp = -Math.log(U) / lambda;
    t += exp;
    if (t &lt; T) {
      n += 1;
      N_t.push(t);
    }
  }

  if (path == false) {
    return n;
  }
  else {
    return N_t;
  }
};

/**
 * A normal distribution in a variate X with mean mu and variance sigma^2 is a statistic distribution with probability density function
 * @param {number} mu
 * @param {number:positive} sigma
 * @param {int:positive} num
 */
var norm = module.exports.norm = function(mu, sigma, num) {
  var U1, U2, x, y, z1, z2;
  var sample = [];

  if (num &lt;= 0 || sigma &lt;= 0) {
    return sample;
  }

  function boxMuller(mu, sigma) {
    U1 = Math.random();
    U2 = Math.random();
    z1 = Math.sqrt(-2 * Math.log(U1)) * Math.cos(2 * U2 * Math.PI);
    z2 = Math.sqrt(-2 * Math.log(U1)) * Math.sin(2 * U2 * Math.PI);
    x = mu + (sigma * z1);
    y = mu + (sigma * z2);
    return [x, y];
  }

  if (typeof num === 'undefined' || num == 1 || (num % 1) != 0) {
    return boxMuller(mu, sigma)[0];
  }

  if (num / 2 % 2 != 0) sample.push(boxMuller(mu, sigma)[0]);
  for (var i = 0; i &lt; Math.floor(num / 2); i++) {
    sample = sample.concat(boxMuller(mu, sigma));
  }
  return sample;
};


/**
 * Returns an array corresponding to the path of Brownian motion (http://en.wikipedia.org/wiki/Wiener_process#Related_processes) from time 0 to T with drift parameter mu and volatility parameter sigma (the process is initialized to be 0). The i-th entry in the array corresponds to the Brownian process at time i * (T/steps).
 * @param {number} mu
 * @param {number:positive} sigma
 * @param {number:positive} T
 * @param {int:positive} steps
 * @param {boolean} path
 */
var brown = module.exports.brown = function(mu, sigma, T, steps, path) {
  var B_t = [0];
  var B = 0;
  var dt = T / steps;
  var dB;

  if (!(T > 0) || !(steps > 0)) {
    return B_t;
  }

  if (path == false) {
    return ((mu * T) + (sigma * norm(0, Math.sqrt(T))));
  }
  else {
    for (var i = 0; i &lt; steps; i++) {
      dB = (mu * dt) + (sigma * norm(0, Math.sqrt(dt)));
      B += dB;
      B_t.push(B);
    }
    return B_t;
  }
};

/**
 * Returns an array corresponding to the path of geometric Brownian motion (http://en.wikipedia.org/wiki/Geometric_Brownian_motion) from time 0 to T with drift parameter mu and volatility parameter sigma (the process is initialized to be S0). The i-th entry in the array corresponds to the geometric Brownian process at time i * (T/steps).
 * (dS/S) = mu*dt + sigma*dW, W(t) ~ norm(0,sqrt(t))
 * @param {number:positive} S0
 * @param {number} mu
 * @param {number:positive} sigma
 * @param {number:positive} T
 * @param {int:positive} steps
 * @param {boolea} path
 */
var GBM = module.exports.GBM = function(S0, mu, sigma, T, steps, path) {
  var S_t = [];

  if (!(T > 0) || !(steps > 0)) {
    return B_t;
  }

  if (path == false) {
    return S0 * Math.exp((mu - (sigma * sigma / 2)) * T + (sigma * norm(0, Math.sqrt(T))));
  }
  else {
    var B_t = brown((mu - (sigma * sigma / 2)), sigma, T, steps);
    B_t.forEach(function(B) {
      S_t.push(S0 * Math.exp(B));
    });
    return S_t;
  }
};

/**
 * Discrete-time Markov chain (DTMC)
 * @param {Array.Array&lt;number>} transMatrix
 * @param {int:positive} steps
 * @param {} start
 * @param {} path
 */
var DTMC = module.exports.DTMC = function(transMatrix, steps, start, path) {
  //function to check if input is a valid transition matrix
  var isValid = function(matrix) {
    var n = matrix.length;
    for (var i = 0; i &lt; n; i++) {
      var sum = 0;
      if (matrix[i].length != n) {
        return false;
      }
      for (var j = 0; j &lt; n; j++) {
        if (matrix[i][j] > 1 || matrix[i][j] &lt; 0) {
          return false;
        }
        sum += matrix[i][j];
      }
      var eps = (4 * Math.pow(10, -16));
      if (sum &lt; 1 - eps || sum > 1 + eps) {
        return false;
      }
    }
    return true;
  };

  //return null if the transition matrix is not valid
  if (!isValid(transMatrix)) {
    return null;
  }

  //initialize the Markov Chain
  var fullPath = [start];
  var stateRow = transMatrix[start];
  var U;

  for (var i = 0; i &lt; steps; i++) {
    U = Math.random();
    var sum = 0;
    for (var j = 0; j &lt; stateRow.length; j++) {
      sum += stateRow[j];
      if (sum > U) {
        fullPath.push(j);
        stateRow = transMatrix[j];
        j = stateRow.length;
      }
    }
  }
  if (path == false) {
    return fullPath[fullPath.length - 1];
  }
  else {
    return fullPath;
  }
};


/**
 * Continuous-time Markov chain (CTMC)
 * @param {} transMatrix
 * @param {} T
 * @param {} start
 * @param {} path
 */
var CTMC = module.exports.CTMC = function(transMatrix, T, start, path) {
  // function to determine if input is a valid CTMC transition matrix
  var isValid = function(matrix) {
    var n = matrix.length;
    for (var i = 0; i &lt; n; i++) {
      if (matrix[i].length != n) {
        return false;
      }
      for (var j = 0; j &lt; n; j++) {
        if (matrix[i][j] &lt; 0) {
          return false;
        }
      }
    }
    return true;
  };

  //return null if the transition matrix is not valid
  if (!isValid(transMatrix)) {
    return null;
  }

  // initialize simulation of the CTMC
  var fullPath = { 0: start };
  var lastState = start;
  var stateRow = transMatrix[start];
  var t = 0;
  var U, exp, sum;

  // begin simulation
  while (t &lt; T) {
    var lambda = 0;
    for (var i = 0; i &lt; stateRow.length; i++) {
      lambda += stateRow[i];
    }
    U = Math.random();
    exp = -Math.log(U) / lambda; //exp is the time to make the transition
    t += exp;

    if (t > T) {
      if (path == false) {
        return lastState;
      }
      else {
        return fullPath;
      }
    }

    sum = 0;
    U = Math.random();
    for (var i = 0; i &lt; stateRow.length; i++) {
      sum += stateRow[i] / lambda;
      if (sum > U) {
        stateRow = transMatrix[i];
        fullPath[t] = i;
        lastState = i;
        i = stateRow.length;
      }
    }
  }
};

/**
 * Generates a random sample (with replacement) from a user input array of observations. Number of observations is specified by the user.
 * @param {Array&lt;number>} arr  
 * @param {int:positive} n 
 */
var sample = module.exports.sample = function(arr, n) {
  var samp = [];
  for (var i = 0; i &lt; n; i++) {
    var index = Math.floor(Math.random() * arr.length);
    var value = arr[index];
    samp.push(value);
  }
  return samp;
};

/**
 * Generates an exponential random variable with rate parameter lambda.
 * @param {number:positive} lambda
 */
var exp = module.exports.exp = function(lambda) {
  return (-Math.log(Math.random()) / lambda);
};

/**
 * The distribution with probability density function 
 * @param {number:positive} x_a
 * @param {number} alpha
 */
var pareto = module.exports.pareto = function(x_m, alpha) {
  return (x_m / Math.pow(Math.random(), 1 / alpha));
};

/**
 * Generates a histogram object from an array of data. Keys denote the lower bound of each bin and the values indicate the frequency of data in each bin.
 * @param {Array&lt;number>} arr 
 */
var hist = module.exports.hist = function(arr) {
  var newArr = arr.slice().sort(function(a, b) {
    return a - b;
  });

  var max = newArr[arr.length - 1];
  var min = newArr[0];
  var bins = Math.round(Math.sqrt(arr.length));
  var binSize = (max - min) / bins;

  var obj = {};
  var keys = [];
  for (var i = 0; i &lt; bins; i++) {
    var key = min + (i * binSize);
    keys.push(key);
    obj[key] = 0;
  }

  for (var j = 0; j &lt; arr.length; j++) {
    var val = min;
    var temp_key = 0;
    while (true) {
      if (newArr[j] == newArr[newArr.length - 1]) {
        obj[keys[keys.length - 1]] += 1;
        break;
      }
      else if (newArr[j] &lt; val + binSize) {
        obj[keys[temp_key]] += 1;
        break;
      }
      else {
        temp_key += 1;
        val += binSize;
      }
    }
  }

  return obj;
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#brown">brown</a></li><li><a href="global.html#CTMC">CTMC</a></li><li><a href="global.html#DTMC">DTMC</a></li><li><a href="global.html#exp">exp</a></li><li><a href="global.html#GBM">GBM</a></li><li><a href="global.html#hist">hist</a></li><li><a href="global.html#norm">norm</a></li><li><a href="global.html#pareto">pareto</a></li><li><a href="global.html#poissP">poissP</a></li><li><a href="global.html#sample">sample</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Sep 10 2016 11:46:22 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
