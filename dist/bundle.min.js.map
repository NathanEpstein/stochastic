{"version":3,"sources":["webpack:///bundle.min.js","webpack:///webpack/bootstrap abb6c1508e2d0e8e7952","webpack:///./dist/index.js","webpack:///./lib/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","window","stoch","poissP","lambda","T","path","U","exp","N_t","t","n","Math","random","log","push","GBM","S0","mu","sigma","steps","S_t","B_t","norm","sqrt","brown","forEach","B","DTMC","transMatrix","start","isValid","matrix","length","i","sum","j","eps","pow","Error","init","parseInt","fullPath","stateRow","CTMC","0","lastState","sample","arr","samp","index","floor","value","pareto","x_m","alpha","hist","newArr","slice","sort","a","b","max","min","bins","round","binSize","obj","keys","key","val","temp_key","cont","Object","defineProperty","num","boxMuller","U1","U2","z1","cos","PI","z2","sin","x","y","concat","dt","dB"],"mappings":"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","file":"bundle.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\twindow.stoch = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.poissP = poissP;\n\texports.GBM = GBM;\n\texports.DTMC = DTMC;\n\texports.CTMC = CTMC;\n\texports.sample = sample;\n\texports.exp = exp;\n\texports.pareto = pareto;\n\texports.hist = hist;\n\t\n\t\n\t/**\n\t * Returns an array with the times of each arrival in a [Poisson Process](http://en.wikipedia.org/wiki/Poisson_process) with rate `lambda` until time `T`.\n\t *\n\t * ![poissP](out/poissP.png)\n\t * @example var poissP = stoch.poissP(1, 100, true);\n\t * @param {number} lambda (rate)\n\t * @param {number} T time as positive number\n\t * @param {boolean} [path=true]\n\t * @returns {number[]} times of each arrival in a Poisson Process\n\t */\n\tfunction poissP(lambda /*: number */\n\t, T /*: number */\n\t, path /*: boolean */) /*: Array<number> */{\n\t  var U = void 0,\n\t      exp = void 0,\n\t      N_t = void 0,\n\t      t = void 0,\n\t      n = void 0;\n\t  N_t = [0];\n\t  t = 0;\n\t  n = 0;\n\t\n\t  if (T <= 0 || lambda <= 0) {\n\t    return N_t;\n\t  }\n\t\n\t  while (t < T) {\n\t    U = Math.random();\n\t    exp = -Math.log(U) / lambda;\n\t    t += exp;\n\t    if (t < T) {\n\t      n += 1;\n\t      N_t.push(t);\n\t    }\n\t  }\n\t\n\t  if (path === false) {\n\t    return [n];\n\t  } else {\n\t    return N_t;\n\t  }\n\t}\n\t\n\t/**\n\t * Returns an array with `num` normal random variables in a [normal distribution](http://en.wikipedia.org/wiki/Normal_distribution) of mean `mu` and standard deviation `sigma`.\n\t *\n\t * ![norm](out/norm.png)\n\t * @example var norm = stoch.norm(1, 1, 100);\n\t * @param {number} mu the mean or expectation of the distribution (and also its median and mode)\n\t * @param {number} sigma standard deviation as positive number\n\t * @param {number} [num=1] a positive integer\n\t * @returns {number[]} normal random values\n\t */\n\tvar norm = exports.norm = function norm(mu /*: number */, sigma /*: number */, num /*: number */) /*: Array<number> */{\n\t  var U1 = void 0,\n\t      U2 = void 0,\n\t      x = void 0,\n\t      y = void 0,\n\t      z1 = void 0,\n\t      z2 = void 0;\n\t  var sample = [];\n\t\n\t  if (num <= 0 || sigma <= 0) {\n\t    return sample;\n\t  }\n\t\n\t  function boxMuller(mu, sigma) {\n\t    U1 = Math.random();\n\t    U2 = Math.random();\n\t    z1 = Math.sqrt(-2 * Math.log(U1)) * Math.cos(2 * U2 * Math.PI);\n\t    z2 = Math.sqrt(-2 * Math.log(U1)) * Math.sin(2 * U2 * Math.PI);\n\t    x = mu + sigma * z1;\n\t    y = mu + sigma * z2;\n\t    return [x, y];\n\t  }\n\t\n\t  if (typeof num === 'undefined' || num === 1 || num % 1 !== 0) {\n\t    return [boxMuller(mu, sigma)[0]];\n\t  }\n\t\n\t  if (num / 2 % 2 !== 0) sample.push(boxMuller(mu, sigma)[0]);\n\t  for (var i = 0; i < Math.floor(num / 2); i++) {\n\t    sample = sample.concat(boxMuller(mu, sigma));\n\t  }\n\t  return sample;\n\t};\n\t\n\t/**\n\t * Returns an array corresponding to the path of [Brownian motion](http://en.wikipedia.org/wiki/Wiener_process#Related_processes) from time 0 to `T` with drift parameter `mu` and volatility parameter `sigma` (the process is initialized to be 0). The i-th entry in the array corresponds to the Brownian process at time `i * (T / steps)`.\n\t *\n\t * ![brown](out/brown.png)\n\t * @example var brown = stoch.brown(1.0, -0.1, +0.1, 100, true);\n\t * @param {number} mu drift parameter (a real number)\n\t * @param {number} sigma volatility parameter (strictly positive real)\n\t * @param {number} T time (strictly positive real)\n\t * @param {number} steps (positive integer)\n\t * @param {boolean} [path=true]\n\t * @return {number[]} Brownian motion path\n\t */\n\tvar brown = exports.brown = function brown(mu /*: number */\n\t, sigma /*: number */\n\t, T /*: number */\n\t, steps /*: number */\n\t, path /*: boolean */) /*: Array<number> */{\n\t  var B_t = [0];\n\t  var B = 0;\n\t  var dt = T / steps;\n\t  var dB = void 0;\n\t\n\t  if (!(T > 0) || !(steps > 0)) {\n\t    return B_t;\n\t  }\n\t\n\t  if (path === false) {\n\t    return [mu * T + sigma * norm(0, Math.sqrt(T), 1)[0]];\n\t  } else {\n\t    for (var i = 0; i < steps; i++) {\n\t      dB = mu * dt + sigma * norm(0, Math.sqrt(dt), 1)[0];\n\t      B += dB;\n\t      B_t.push(B);\n\t    }\n\t    return B_t;\n\t  }\n\t};\n\t\n\t/**\n\t * Returns an array corresponding to the path of [geometric Brownian motion](http://en.wikipedia.org/wiki/Geometric_Brownian_motion) from time 0 to `T` with drift parameter `mu` and volatility parameter `sigma` (the process is initialized to be S0). The i-th entry in the array corresponds to the geometric Brownian process at time `i * (T/steps)`.\n\t *\n\t * ![GBM](out/GBM.png)\n\t * @example var GBM = stoch.GBM(1.0, -0.1, 0.1, 1.0, 100, true);\n\t * @param {number} S0 initialized process value\n\t * @param {number} mu drift parameter\n\t * @param {number} sigma volatility parameter (strictly positive real)\n\t * @param {number} T time (strictly positive real)\n\t * @param {number} steps (positive integer)\n\t * @param {boolean} [path=true]\n\t * @returns {number[]} geometric Brownian motion\n\t */\n\tfunction GBM(S0 /*: number */\n\t, mu /*:number */\n\t, sigma /*: number */\n\t, T /*: number */\n\t, steps /*: number */\n\t, path /*: boolean */) /*: Array<number> */{\n\t  var S_t = [];\n\t  var B_t = [0];\n\t\n\t  if (!(T > 0) || !(steps > 0)) {\n\t    return B_t;\n\t  }\n\t\n\t  if (path === false) {\n\t    return [S0 * Math.exp((mu - sigma * sigma / 2) * T + sigma * norm(0, Math.sqrt(T), 1)[0])];\n\t  } else {\n\t    B_t = brown(mu - sigma * sigma / 2, sigma, T, steps, true);\n\t    B_t.forEach(function (B) {\n\t      S_t.push(S0 * Math.exp(B));\n\t    });\n\t    return S_t;\n\t  }\n\t}\n\t\n\t/**\n\t * Returns an array with the states at each step of the [discrete-time Markov Chain](http://en.wikipedia.org/wiki/Markov_chain) given by `transMatrix` (a square matrix). The number of transitions is given by `steps`. The initial state is given by start (the states are indexed from 0 to n-1 where n is the number of arrays in transMatrix).\n\t *\n\t * ![DTMC](out/DTMC.png)\n\t * @example var DTMC = stoch.DTMC([[0,1,0],[0,0,1],[1,0,0]], 20, 0, true);\n\t * @param {Array<Array<number>>} transMatrix\n\t * @param {number} steps (positive integer)\n\t * @param {number} start\n\t * @param {boolean} path\n\t * @returns {number[]}\n\t */\n\tfunction DTMC(transMatrix /*: Array<Array<number>> */\n\t, steps /*: number */\n\t, start /*: number */\n\t, path /*: boolean */) /*: Array<number> */{\n\t  //function to check if input is a valid transition matrix\n\t  var isValid = function isValid(matrix) {\n\t    var n = matrix.length;\n\t    for (var i = 0; i < n; i++) {\n\t      var sum = 0;\n\t      if (matrix[i].length !== n) {\n\t        return false;\n\t      }\n\t      for (var j = 0; j < n; j++) {\n\t        if (matrix[i][j] > 1 || matrix[i][j] < 0) {\n\t          return false;\n\t        }\n\t        sum += matrix[i][j];\n\t      }\n\t      var eps = 4 * Math.pow(10, -16);\n\t      if (sum < 1 - eps || sum > 1 + eps) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  };\n\t\n\t  //return null if the transition matrix is not valid\n\t  if (!isValid(transMatrix)) {\n\t    throw new Error(\"Invalid transMatrix\");\n\t  }\n\t\n\t  //initialize the Markov Chain\n\t  var init = parseInt(start, 10);\n\t  var fullPath = [];\n\t  fullPath.push(init);\n\t  var stateRow = transMatrix[init];\n\t  var U = void 0;\n\t\n\t  for (var i = 0; i < steps; i++) {\n\t    U = Math.random();\n\t    var sum = 0;\n\t    for (var j = 0; j < stateRow.length; j++) {\n\t      sum += stateRow[j];\n\t      if (sum > U) {\n\t        fullPath.push(j);\n\t        stateRow = transMatrix[j];\n\t        j = stateRow.length;\n\t      }\n\t    }\n\t  }\n\t  if (path === false) {\n\t    return fullPath[fullPath.length - 1];\n\t  } else {\n\t    return fullPath;\n\t  }\n\t}\n\t\n\t/**\n\t * Returns an object with the {key:value} pair {time:state} at each step of the [continuous-time Markov Chain](http://en.wikipedia.org/wiki/Continuous-time_Markov_chain) given by transMatrix (a square matrix). The Markov Chain is simulated until time `T`. The initial state is given by `start` (the states are indexed from 0 to n-1 where n is the number of arrays in `transMatrix`).\n\t *\n\t * ![CTMC](out/CTMC.png)\n\t * @example var CTMC = stoch.CTMC([[0,1,0],[0,0,1],[1,0,0]], 20, 0, true);\n\t * @param {Array<Array<number>>} transMatrix\n\t * @param {number} T\n\t * @param {number} start\n\t * @param {boolean} [path=true]\n\t * @returns {Object} Continuous-time Markov chain\n\t */\n\tfunction CTMC(transMatrix /*: Array<Array<number>> */\n\t, T /*: number */\n\t, start /*: number */\n\t, path /*: boolean */) /*: {[ts:string]: number} */{\n\t  // function to determine if input is a valid CTMC transition matrix\n\t  var isValid = function isValid(matrix) {\n\t    var n = matrix.length;\n\t    for (var i = 0; i < n; i++) {\n\t      if (matrix[i].length !== n) {\n\t        return false;\n\t      }\n\t      for (var j = 0; j < n; j++) {\n\t        if (matrix[i][j] < 0) {\n\t          return false;\n\t        }\n\t      }\n\t    }\n\t    return true;\n\t  };\n\t\n\t  //return null if the transition matrix is not valid\n\t  if (!isValid(transMatrix)) {\n\t    throw new Error(\"Invalid transMatrix\");\n\t  }\n\t\n\t  // initialize simulation of the CTMC\n\t  var fullPath = { \"0\": start };\n\t  var lastState = start;\n\t  var stateRow = transMatrix[start];\n\t  var t = 0;\n\t  var U = void 0,\n\t      exp = void 0,\n\t      sum = void 0;\n\t\n\t  // begin simulation\n\t  while (t < T) {\n\t    var lambda = 0;\n\t    for (var i = 0; i < stateRow.length; i++) {\n\t      lambda += stateRow[i];\n\t    }\n\t    U = Math.random();\n\t    exp = -Math.log(U) / lambda; //exp is the time to make the transition\n\t    t += exp;\n\t\n\t    if (t > T) {\n\t      if (path === false) {\n\t        return { t: lastState };\n\t      } else {\n\t        return fullPath;\n\t      }\n\t    }\n\t\n\t    sum = 0;\n\t    U = Math.random();\n\t    for (var j = 0; j < stateRow.length; j++) {\n\t      sum += stateRow[j] / lambda;\n\t      if (sum > U) {\n\t        stateRow = transMatrix[j];\n\t        fullPath[t] = j;\n\t        lastState = j;\n\t        j = stateRow.length;\n\t      }\n\t    }\n\t  }\n\t  return fullPath;\n\t}\n\t\n\t/**\n\t * Generates a random sample (with replacement) from array `arr` of observations. Number of observations `n` is specified by the user.\n\t * @example var sample = stoch.sample([1,2,3,4,5], +10);\n\t * @param {number[]} arr\n\t * @param {number} n (positive integer)\n\t * @returns {number[]} random sample\n\t */\n\tfunction sample(arr /*: number[] */, n /*: number */) /*: Array<number> */{\n\t  var samp = [];\n\t  for (var i = 0; i < n; i++) {\n\t    var index = Math.floor(Math.random() * arr.length);\n\t    var value = arr[index];\n\t    samp.push(value);\n\t  }\n\t  return samp;\n\t}\n\t\n\t/**\n\t * Generates an exponential random variable with rate parameter `lambda`.\n\t * @example var exp = stoch.exp(20);\n\t * @param {number} lambda (positive)\n\t * @returns {number} variable\n\t */\n\tfunction exp(lambda /*: number */) /*: number */{\n\t  return -Math.log(Math.random()) / lambda;\n\t}\n\t\n\t/**\n\t * Generates a Pareto random variables with parameters `x_m` and `alpha`.\n\t * @example var pareto = stoch.pareto(+20.0, -1.0);\n\t * @param {number} x_a (positive)\n\t * @param {number} alpha\n\t * @returns {number} distribution\n\t */\n\tfunction pareto(x_m /*: number */, alpha /*: number */) /*: number */{\n\t  return x_m / Math.pow(Math.random(), 1 / alpha);\n\t}\n\t\n\t/**\n\t * Generates a histogram object from an array of data. Keys denote the lower bound of each bin and the values indicate the frequency of data in each bin.\n\t *\n\t * ![hist](out/hist.png)\n\t * @example var hist = stoch.hist([1,1,1,1,2,3,3,4,4,4]);\n\t * @param {Array<number>} arr\n\t * @returns {Object} histogram\n\t */\n\tfunction hist(arr /*: Array<number> */) {\n\t  var newArr = arr.slice().sort(function (a, b) {\n\t    return a - b;\n\t  });\n\t\n\t  var max = newArr[arr.length - 1];\n\t  var min = newArr[0];\n\t  var bins = Math.round(Math.sqrt(arr.length));\n\t  var binSize = (max - min) / bins;\n\t\n\t  var obj = {};\n\t  var keys = [];\n\t  for (var i = 0; i < bins; i++) {\n\t    var key = min + i * binSize;\n\t    keys.push(key);\n\t    obj[key] = 0;\n\t  }\n\t\n\t  for (var j = 0; j < arr.length; j++) {\n\t    var val = min;\n\t    var temp_key = 0;\n\t    var cont = true;\n\t    while (cont) {\n\t      if (newArr[j] === newArr[newArr.length - 1]) {\n\t        obj[keys[keys.length - 1]] += 1;\n\t        cont = false;\n\t        break;\n\t      } else if (newArr[j] < val + binSize) {\n\t        obj[keys[temp_key]] += 1;\n\t        cont = false;\n\t        break;\n\t      } else {\n\t        temp_key += 1;\n\t        val += binSize;\n\t      }\n\t    }\n\t  }\n\t\n\t  return obj;\n\t}\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** bundle.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap abb6c1508e2d0e8e7952\n **/","window.stoch = require('../lib/index.js');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./dist/index.js\n ** module id = 0\n ** module chunks = 0\n **/","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.poissP = poissP;\nexports.GBM = GBM;\nexports.DTMC = DTMC;\nexports.CTMC = CTMC;\nexports.sample = sample;\nexports.exp = exp;\nexports.pareto = pareto;\nexports.hist = hist;\n\n\n/**\n * Returns an array with the times of each arrival in a [Poisson Process](http://en.wikipedia.org/wiki/Poisson_process) with rate `lambda` until time `T`.\n *\n * ![poissP](out/poissP.png)\n * @example var poissP = stoch.poissP(1, 100, true);\n * @param {number} lambda (rate)\n * @param {number} T time as positive number\n * @param {boolean} [path=true]\n * @returns {number[]} times of each arrival in a Poisson Process\n */\nfunction poissP(lambda /*: number */\n, T /*: number */\n, path /*: boolean */) /*: Array<number> */{\n  var U = void 0,\n      exp = void 0,\n      N_t = void 0,\n      t = void 0,\n      n = void 0;\n  N_t = [0];\n  t = 0;\n  n = 0;\n\n  if (T <= 0 || lambda <= 0) {\n    return N_t;\n  }\n\n  while (t < T) {\n    U = Math.random();\n    exp = -Math.log(U) / lambda;\n    t += exp;\n    if (t < T) {\n      n += 1;\n      N_t.push(t);\n    }\n  }\n\n  if (path === false) {\n    return [n];\n  } else {\n    return N_t;\n  }\n}\n\n/**\n * Returns an array with `num` normal random variables in a [normal distribution](http://en.wikipedia.org/wiki/Normal_distribution) of mean `mu` and standard deviation `sigma`.\n *\n * ![norm](out/norm.png)\n * @example var norm = stoch.norm(1, 1, 100);\n * @param {number} mu the mean or expectation of the distribution (and also its median and mode)\n * @param {number} sigma standard deviation as positive number\n * @param {number} [num=1] a positive integer\n * @returns {number[]} normal random values\n */\nvar norm = exports.norm = function norm(mu /*: number */, sigma /*: number */, num /*: number */) /*: Array<number> */{\n  var U1 = void 0,\n      U2 = void 0,\n      x = void 0,\n      y = void 0,\n      z1 = void 0,\n      z2 = void 0;\n  var sample = [];\n\n  if (num <= 0 || sigma <= 0) {\n    return sample;\n  }\n\n  function boxMuller(mu, sigma) {\n    U1 = Math.random();\n    U2 = Math.random();\n    z1 = Math.sqrt(-2 * Math.log(U1)) * Math.cos(2 * U2 * Math.PI);\n    z2 = Math.sqrt(-2 * Math.log(U1)) * Math.sin(2 * U2 * Math.PI);\n    x = mu + sigma * z1;\n    y = mu + sigma * z2;\n    return [x, y];\n  }\n\n  if (typeof num === 'undefined' || num === 1 || num % 1 !== 0) {\n    return [boxMuller(mu, sigma)[0]];\n  }\n\n  if (num / 2 % 2 !== 0) sample.push(boxMuller(mu, sigma)[0]);\n  for (var i = 0; i < Math.floor(num / 2); i++) {\n    sample = sample.concat(boxMuller(mu, sigma));\n  }\n  return sample;\n};\n\n/**\n * Returns an array corresponding to the path of [Brownian motion](http://en.wikipedia.org/wiki/Wiener_process#Related_processes) from time 0 to `T` with drift parameter `mu` and volatility parameter `sigma` (the process is initialized to be 0). The i-th entry in the array corresponds to the Brownian process at time `i * (T / steps)`.\n *\n * ![brown](out/brown.png)\n * @example var brown = stoch.brown(1.0, -0.1, +0.1, 100, true);\n * @param {number} mu drift parameter (a real number)\n * @param {number} sigma volatility parameter (strictly positive real)\n * @param {number} T time (strictly positive real)\n * @param {number} steps (positive integer)\n * @param {boolean} [path=true]\n * @return {number[]} Brownian motion path\n */\nvar brown = exports.brown = function brown(mu /*: number */\n, sigma /*: number */\n, T /*: number */\n, steps /*: number */\n, path /*: boolean */) /*: Array<number> */{\n  var B_t = [0];\n  var B = 0;\n  var dt = T / steps;\n  var dB = void 0;\n\n  if (!(T > 0) || !(steps > 0)) {\n    return B_t;\n  }\n\n  if (path === false) {\n    return [mu * T + sigma * norm(0, Math.sqrt(T), 1)[0]];\n  } else {\n    for (var i = 0; i < steps; i++) {\n      dB = mu * dt + sigma * norm(0, Math.sqrt(dt), 1)[0];\n      B += dB;\n      B_t.push(B);\n    }\n    return B_t;\n  }\n};\n\n/**\n * Returns an array corresponding to the path of [geometric Brownian motion](http://en.wikipedia.org/wiki/Geometric_Brownian_motion) from time 0 to `T` with drift parameter `mu` and volatility parameter `sigma` (the process is initialized to be S0). The i-th entry in the array corresponds to the geometric Brownian process at time `i * (T/steps)`.\n *\n * ![GBM](out/GBM.png)\n * @example var GBM = stoch.GBM(1.0, -0.1, 0.1, 1.0, 100, true);\n * @param {number} S0 initialized process value\n * @param {number} mu drift parameter\n * @param {number} sigma volatility parameter (strictly positive real)\n * @param {number} T time (strictly positive real)\n * @param {number} steps (positive integer)\n * @param {boolean} [path=true]\n * @returns {number[]} geometric Brownian motion\n */\nfunction GBM(S0 /*: number */\n, mu /*:number */\n, sigma /*: number */\n, T /*: number */\n, steps /*: number */\n, path /*: boolean */) /*: Array<number> */{\n  var S_t = [];\n  var B_t = [0];\n\n  if (!(T > 0) || !(steps > 0)) {\n    return B_t;\n  }\n\n  if (path === false) {\n    return [S0 * Math.exp((mu - sigma * sigma / 2) * T + sigma * norm(0, Math.sqrt(T), 1)[0])];\n  } else {\n    B_t = brown(mu - sigma * sigma / 2, sigma, T, steps, true);\n    B_t.forEach(function (B) {\n      S_t.push(S0 * Math.exp(B));\n    });\n    return S_t;\n  }\n}\n\n/**\n * Returns an array with the states at each step of the [discrete-time Markov Chain](http://en.wikipedia.org/wiki/Markov_chain) given by `transMatrix` (a square matrix). The number of transitions is given by `steps`. The initial state is given by start (the states are indexed from 0 to n-1 where n is the number of arrays in transMatrix).\n *\n * ![DTMC](out/DTMC.png)\n * @example var DTMC = stoch.DTMC([[0,1,0],[0,0,1],[1,0,0]], 20, 0, true);\n * @param {Array<Array<number>>} transMatrix\n * @param {number} steps (positive integer)\n * @param {number} start\n * @param {boolean} path\n * @returns {number[]}\n */\nfunction DTMC(transMatrix /*: Array<Array<number>> */\n, steps /*: number */\n, start /*: number */\n, path /*: boolean */) /*: Array<number> */{\n  //function to check if input is a valid transition matrix\n  var isValid = function isValid(matrix) {\n    var n = matrix.length;\n    for (var i = 0; i < n; i++) {\n      var sum = 0;\n      if (matrix[i].length !== n) {\n        return false;\n      }\n      for (var j = 0; j < n; j++) {\n        if (matrix[i][j] > 1 || matrix[i][j] < 0) {\n          return false;\n        }\n        sum += matrix[i][j];\n      }\n      var eps = 4 * Math.pow(10, -16);\n      if (sum < 1 - eps || sum > 1 + eps) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  //return null if the transition matrix is not valid\n  if (!isValid(transMatrix)) {\n    throw new Error(\"Invalid transMatrix\");\n  }\n\n  //initialize the Markov Chain\n  var init = parseInt(start, 10);\n  var fullPath = [];\n  fullPath.push(init);\n  var stateRow = transMatrix[init];\n  var U = void 0;\n\n  for (var i = 0; i < steps; i++) {\n    U = Math.random();\n    var sum = 0;\n    for (var j = 0; j < stateRow.length; j++) {\n      sum += stateRow[j];\n      if (sum > U) {\n        fullPath.push(j);\n        stateRow = transMatrix[j];\n        j = stateRow.length;\n      }\n    }\n  }\n  if (path === false) {\n    return fullPath[fullPath.length - 1];\n  } else {\n    return fullPath;\n  }\n}\n\n/**\n * Returns an object with the {key:value} pair {time:state} at each step of the [continuous-time Markov Chain](http://en.wikipedia.org/wiki/Continuous-time_Markov_chain) given by transMatrix (a square matrix). The Markov Chain is simulated until time `T`. The initial state is given by `start` (the states are indexed from 0 to n-1 where n is the number of arrays in `transMatrix`).\n *\n * ![CTMC](out/CTMC.png)\n * @example var CTMC = stoch.CTMC([[0,1,0],[0,0,1],[1,0,0]], 20, 0, true);\n * @param {Array<Array<number>>} transMatrix\n * @param {number} T\n * @param {number} start\n * @param {boolean} [path=true]\n * @returns {Object} Continuous-time Markov chain\n */\nfunction CTMC(transMatrix /*: Array<Array<number>> */\n, T /*: number */\n, start /*: number */\n, path /*: boolean */) /*: {[ts:string]: number} */{\n  // function to determine if input is a valid CTMC transition matrix\n  var isValid = function isValid(matrix) {\n    var n = matrix.length;\n    for (var i = 0; i < n; i++) {\n      if (matrix[i].length !== n) {\n        return false;\n      }\n      for (var j = 0; j < n; j++) {\n        if (matrix[i][j] < 0) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  //return null if the transition matrix is not valid\n  if (!isValid(transMatrix)) {\n    throw new Error(\"Invalid transMatrix\");\n  }\n\n  // initialize simulation of the CTMC\n  var fullPath = { \"0\": start };\n  var lastState = start;\n  var stateRow = transMatrix[start];\n  var t = 0;\n  var U = void 0,\n      exp = void 0,\n      sum = void 0;\n\n  // begin simulation\n  while (t < T) {\n    var lambda = 0;\n    for (var i = 0; i < stateRow.length; i++) {\n      lambda += stateRow[i];\n    }\n    U = Math.random();\n    exp = -Math.log(U) / lambda; //exp is the time to make the transition\n    t += exp;\n\n    if (t > T) {\n      if (path === false) {\n        return { t: lastState };\n      } else {\n        return fullPath;\n      }\n    }\n\n    sum = 0;\n    U = Math.random();\n    for (var j = 0; j < stateRow.length; j++) {\n      sum += stateRow[j] / lambda;\n      if (sum > U) {\n        stateRow = transMatrix[j];\n        fullPath[t] = j;\n        lastState = j;\n        j = stateRow.length;\n      }\n    }\n  }\n  return fullPath;\n}\n\n/**\n * Generates a random sample (with replacement) from array `arr` of observations. Number of observations `n` is specified by the user.\n * @example var sample = stoch.sample([1,2,3,4,5], +10);\n * @param {number[]} arr\n * @param {number} n (positive integer)\n * @returns {number[]} random sample\n */\nfunction sample(arr /*: number[] */, n /*: number */) /*: Array<number> */{\n  var samp = [];\n  for (var i = 0; i < n; i++) {\n    var index = Math.floor(Math.random() * arr.length);\n    var value = arr[index];\n    samp.push(value);\n  }\n  return samp;\n}\n\n/**\n * Generates an exponential random variable with rate parameter `lambda`.\n * @example var exp = stoch.exp(20);\n * @param {number} lambda (positive)\n * @returns {number} variable\n */\nfunction exp(lambda /*: number */) /*: number */{\n  return -Math.log(Math.random()) / lambda;\n}\n\n/**\n * Generates a Pareto random variables with parameters `x_m` and `alpha`.\n * @example var pareto = stoch.pareto(+20.0, -1.0);\n * @param {number} x_a (positive)\n * @param {number} alpha\n * @returns {number} distribution\n */\nfunction pareto(x_m /*: number */, alpha /*: number */) /*: number */{\n  return x_m / Math.pow(Math.random(), 1 / alpha);\n}\n\n/**\n * Generates a histogram object from an array of data. Keys denote the lower bound of each bin and the values indicate the frequency of data in each bin.\n *\n * ![hist](out/hist.png)\n * @example var hist = stoch.hist([1,1,1,1,2,3,3,4,4,4]);\n * @param {Array<number>} arr\n * @returns {Object} histogram\n */\nfunction hist(arr /*: Array<number> */) {\n  var newArr = arr.slice().sort(function (a, b) {\n    return a - b;\n  });\n\n  var max = newArr[arr.length - 1];\n  var min = newArr[0];\n  var bins = Math.round(Math.sqrt(arr.length));\n  var binSize = (max - min) / bins;\n\n  var obj = {};\n  var keys = [];\n  for (var i = 0; i < bins; i++) {\n    var key = min + i * binSize;\n    keys.push(key);\n    obj[key] = 0;\n  }\n\n  for (var j = 0; j < arr.length; j++) {\n    var val = min;\n    var temp_key = 0;\n    var cont = true;\n    while (cont) {\n      if (newArr[j] === newArr[newArr.length - 1]) {\n        obj[keys[keys.length - 1]] += 1;\n        cont = false;\n        break;\n      } else if (newArr[j] < val + binSize) {\n        obj[keys[temp_key]] += 1;\n        cont = false;\n        break;\n      } else {\n        temp_key += 1;\n        val += binSize;\n      }\n    }\n  }\n\n  return obj;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/index.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}